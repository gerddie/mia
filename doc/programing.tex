\documentclass[english, 10pt, a4paper,headsepline,openany]{scrbook}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[left=2cm,right=1cm,top=2cm,bottom=2cm,twoside]{geometry}
\usepackage{array}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[numbers]{natbib}
\usepackage{listings}
\usepackage{color}
\usepackage{graphics}
\usepackage{nonfloat}
\usepackage{babel}
\usepackage[colorlinks,linkcolor=blue]{hyperref}
\usepackage{multirow}
\usepackage{ifthen}
\usepackage{tabularx}
\usepackage{rotating}
\usepackage{float}
\usepackage{colortbl}
\newcommand{\has}{\cellcolor[gray]{0.5}}

\floatstyle{ruled}
\newfloat{listing}{tbp}{lop}[section]



\include{version}
\include{definitions}

%\makeatletter
\definecolor{listinggray}{gray}{0.9}
\lstset{backgroundcolor=\color{listinggray}}


\makeatother


\title{MIA Programming Guide}

\begin{document}
\lstset{numbers=left, numberstyle=\small, numbersep=5pt}

This part of the MIA guide decribes, how to use the interfaces provided to write your own software,
  how to extend the the functionallity of MIA without touchting its core, and, finally, how to 
  extend the core funcionallity MIA itself.
\begin{itemize}
\item In chapter \ref{ch:simple} an example is provided, that describes how to scan the command line, load an image, 
  run some given filters on it and store the image. 
\item Chapter \ref{ch:images} focuses images on writing an image filter that can handle various different 
   gray scale pixel formats.
\item Chapter \ref{ch:io} decribes how to teach MIA to read and write additional image formats. 
\item Chapter \ref{ch:addpluginstype} gives an insight how to create a new class of plug-ins.
\end{itemize}

Note, that the code examples make use of C++0x features like the {\bf auto} for automatic 
  type deduction and \emph{lambda} expressions. 

\chapter{A simple program}
\label{ch:simple}

This chapter will teach you how to use the MIA-tools to scan command line parameters, read and store images, 
  create filters opbejcts from plug-ins and apply filter chains to the images. 
In summary, the program described here is the \texttt{mia-2dimagefilter} from \texttt{src/2dimagefilter.cc}. 

For convenience the full source code is printed in the listning below, and we will go through it line by line. 
\lstset{language=c++,basicstyle=\small,numberstyle=\small}
\begin{lstlisting}
#include <mia/core.hh>
#include <mia/2d.hh>

NS_MIA_USE;
using namespace std;

static const char *program_info = 
	"This program is used to filter and convert gray scale images.\n"
	"Basic usage:\n"
	"  mia-2dimagefilter -i <input image> -o <output image> [<plugin>] ...\n"; 

int do_main( int argc, const char *argv[] )
{

	string in_filename;
	string out_filename;
	string out_type;

	const auto& filter_plugins = C2DFilterPluginHandler::instance();
	const auto& imageio = C2DImageIOPluginHandler::instance();

	CCmdOptionList options(program_info);
	options.add(make_opt( in_filename, "in-file", 'i', 
                "input image(s) to be filtered", CCmdOption::required));
	options.add(make_opt( out_filename, "out-file", 'o',
		"output image(s) that have been filtered", CCmdOption::required));
	options.add(make_opt( out_type, imageio.get_set(), "type", 't',
		"output file type (override suffix)"));
	options.add(g_help_optiongroup, 
	        make_help_opt( "help-plugins", 0,
		   "give some help about the filter plugins", 
	  	   new TPluginHandlerHelpCallback<C2DFilterPluginHandler>));
	
	if (options.parse(argc, argv) != CCmdOptionList::hr_no)
		return EXIT_SUCCESS; 
	auto filter_chain = options.get_remaining();

	if ( filter_chain.empty() )
		cvwarn() << "no filters given, just copy\n";

	std::vector<C2DFilterPlugin::ProductPtr> filters(filter_chain.size());
	transform(filter_chain.begin(), filter_chain.end(), filters.begin(),
		  [&filter_plugins](const char * name) {
			  auto filter =  filter_plugins.produce(name); 
			  if (!filter) {
				  THROW(invalid_argument, "Filter '" << name << "' not found"); 
			  }
			  return filter; 
		  }
		); 
		
	auto in_image_list = imageio.load(in_filename);
	if (!in_image_list || in_image_list->empty()) {
		THROW(invalid_argument, "No images found in " << in_filename); 
	}
	
	for (auto f = filters.begin(); f != filters.end(); ++f) {
		cvmsg() << "Run filter: " << (*f)->get_init_string() << "\n";
		transform(in_image_list->begin(), in_image_list->end(), in_image_list->begin(),
			  [f](const P2DImage& img){return  (*f)->filter(*img);}); 
	}
	
	if ( !imageio.save(out_type, out_filename, *in_image_list) ){
		THROW(runtime_error, "Unable to save result to " << out_filename);
	};
	return EXIT_SUCCESS;

}

int main( int argc, const char *argv[] )
{
	try {
		return do_main(argc, argv);
	}
	catch (const runtime_error &e){
		cerr << argv[0] << " runtime: " << e.what() << endl;
	}
	catch (const invalid_argument &e){
		cerr << argv[0] << " error: " << e.what() << endl;
	}
	catch (const exception& e){
		cerr << argv[0] << " error: " << e.what() << endl;
	}
	catch (...){
		cerr << argv[0] << " unknown exception" << endl;
	}

	return EXIT_FAILURE;
}
\end{lstlisting}  

\begin{description}
\item [1:] For option parsing include the core of the MIA library. 
\item [2:] For 2D image handling pull in the apropriate declaration. 
\item [4,5:] Using the MIA and STD to save some typing.\footnote{%
For further reading on when it is okay to use the using statement please consulte \citet{sutter05coding}}
\item [7-10:] Define the header for the help output. 
\item [12-74:] The body of the true main function. 
    To reduce intentions resultin from the global try-catch statement, this body is put into an extra function. 
\item [15-17:]
    Declare some variables, that are needed for the command line parsing, namely the input and output file names, 
    the output file format (if not given the file format is deducted from the output file name), and a flag 
    see if the user requests some help on the supported filter plugins. 
    The values given to these variables will be the default values for the options. 
     As an exception, boolean values are always default to ``false''. 
\item [19,20:] Define some short cuts for the plugin handlers.
\item [22-32:] Define the options for this program using the variables given above. 
    Silently, in the background are some more options available, that deal with common tasks, such as printing out the general
      help, printing out copyright information, and verbosity level of the output. 
    See chapter \ref{ch:prog} for details. 
\item [34-36:] Parse the command line and check if a help option was used. 
     For this program, the remaining command line parameters describe the filters to be applied. 
     A command line like 
     \lstset{language=bash,numbers=none}
     \begin{lstlisting}
eva-2dimagefilter -i input.png -o output.png \
    downscale:bx=2,by=2 bandpass:min=20,max=200
    \end{lstlisting}
      will be parsed like follows:
      \begin{itemize}
      \item  \texttt{in\_filename} = ``input.png''
      \item  \texttt{out\_filename} = ``output.png''
      \item  \texttt{filter\_chain} = (downscale:bx=2,by=2, bandpass:min=20,max=200)
      \end{itemize}

\item [38-39:] Print out some warning if no filters were given. 

\item [41-50:] Create the filter chain by using the filter descriptions from the command line. 
       If the creation of one filter fails, an \texttt{invalid\_argument} exception is thrown, 
        which will terminate the  program with an error message. 
\item [52-55:] Load the image(s) from the input file. 
       If no input image is found, throw an \texttt{invalid\_argument} exception that will terminate 
         the program with an error message. 
\item [57-61:] Apply the filters to all input images replacing the input images. 
       Since the images are all wrapped into shared pointers, no memory leaks will be introduced by this code. 
\item [63-65:] Save the filtered image(s) in the output file. If not successfull throw an exception.
\item [67:] Terminate the program with the return value indicating success.
\item [71-90:] The body of the main function that encapsulates the real functionallity into a try 
      catch block that is used to report error messages. 
\end{description}

\chapter{Basic operations on Images}

\label{ch:images}

In the following, the basic handling of images is described. 
All the examples will use 2D images. 
If not otherwise noted, 3D images are handled likewise - you only need to change 2D to 3D in the 
  class and function names. 

\section{Creating, copying, loading, and storing images}

The images supported in MIA  may contain different pixel types, e.g. 1-bit, 8-bit, 16-bit, or float valued ones. 
MIA uses shared pointers \texttt{P2DImage} to \texttt{C2DImage}, respectively,  to hold images. 
However, in order to account for the pixel type, at creation time a derivative class of the used pixel 
   type needs to be specified. 
In order to create an 16-bit image with unsigned pixel values with a given \texttt{size}, use:

\lstset{numbers=none}
\begin{lstlisting}
P2DImage image = P2DImage(new C2DUSImage(size)); 
\end{lstlisting}

All images may store meta-data that hold information that may be irrelevant to image processig 
  but should be preserves to keep track of the image processing. 
This data is stored in an attribute list that is actually the base class for the image classes. 
Attributes can be of an abitrary type but only a certain subset of attribute types is predefined. 

Adding an attribute to an image is done like this: 
\begin{lstlisting}
PAttribute attr(new CDoubleAttribute(1.2));  
image->set_attribute("key", attr);
\end{lstlisting}

Since most of the time attributes that are bound to a certain key are of a specific type, 
  translater functions exists that enable passing a string to the set\_attribute function,  
  and the translater will take care of creating the proper attribute type. 
\begin{lstlisting}
image->set_attribute("key", "1.2");
\end{lstlisting}


In order to copy all the meta-data of anothe image at creation time, one may give the reference image 
  as additional parameter to the constructor.

\begin{lstlisting}
P2DImage new_image = P2DImage(new C2DUSImage(size, *image));
\end{lstlisting}
 
In order to copy an image with all its meta-data the image class provides the clone function: 
\begin{lstlisting}
P2DImage image_copy = image->clone();
\end{lstlisting}

Of course all images can also be loaded and stored to files. 
Two options are provided to load and store images: 
  The generic approach uses the \texttt{load} and \texttt{write} methods of the according image IO 
    plugin handler. 
  Since some image formats support storing more than one image frame these methods 
    handle lists of images. 
For instance to load all images from a file \texttt{images.tiff} do 
\begin{lstlisting}
	auto images = C2DImageIOPluginHandler::instance().load("images.tiff");
\end{lstlisting}
In this case images is a \texttt{std::vector<P2DImage>} and you can access the actual images by 
  using the functions provided by this template. 
In order to store a series of images to a file \texttt{output.tiff} just call 
\begin{lstlisting}
	bool success  = C2DImageIOPluginHandler::instance().save("output.tiff", images);
\end{lstlisting}


If you want to load or store just one image per file, then convenicence functions exists, 
   that take care of the handling packing and unpacking the image into and from lists. 
If a file contains more then one frame, with these functions only the first image will be loaded. 
In this case loading the image from \texttt{image.png} boils down to calling 
\begin{lstlisting}
        P2DImage image = load_image2d("image.png"); 
\end{lstlisting}
Note, however, that \texttt{load\_image2d} will throw a \texttt{runtime\_exception} of no image 
  could be loaded. 

Saving an image is done by 
\begin{lstlisting}
        bool success = save_image2d("image.png", image); 
\end{lstlisting}


\section{About Image Filters}
\label{sec:filter}

In order to access the image data, its pixel type needs to be known. 
Of course it is possible to use the \texttt{get\_type} method of the \texttt{C2DImage} class and use
  a switch statement in order to cast to the appropriate derived class. 
However, since this needs to be done very often, MIA provides various template functions to handle 
  this conversion.
These functions are defined in \texttt{<mia/core/filter.hh>} and examples of its use are given below. 

\subsection{The single image filter}

The simples of all filter functions takes exactly one image as input and returns the filterde image. 
The filter function is defined as: 

\lstset{numbers=left,firstnumber=auto}
\begin{lstlisting}{FilterExample}
template <typename Filter, typename Image>
static typename Filter::result_type filter(const Filter& f, const Image& b)
\end{lstlisting}

In the current implementation of MIA, \texttt{Image} will be either \texttt{C2DImage} or \texttt{C3DImage}. 
\texttt{Filter} is a functor class that must provied the a type \texttt{result\_type} and an 
  operator \texttt{()}.
The most basic declaration of such a filter that takes a 2D image as input and has a 2D image as 
   output would look like 
\begin{lstlisting}{FilterExample}
class CSimpleFilter {
public: 
  typedef mia::P2DImage result_type; 
  
  template <typename T> 
  result_type operator()(const T2DImage<T>& image) const; 
}
\end{lstlisting}

Note, that the operator () is templated with respect to the image pixel type and that its parameter image 
  and the operator itself is defined as constant. 
This means, logically a filter should acts as a function whose result only depends on the input image 
(and possible parameters passed to a non-trivial constructor). 

In listing \ref{list:filterthreshold} you can find the complete declaration and definition of a filter 
  that runs a thresholding operation by setting all pixels in the image below the given threshold to zero 
  and all values above or equal to one. 
The output will be a bit valued image. 

\begin{listing}
\begin{lstlisting}{ThresholdFilterExample}
#include <algorithm>
class C2DTreshholdFilter {
public: 
  typedef mia::P2DImage result_type; 
  
  C2DTreshholdFilter(double threshold); 

  template <typename T> 
  result_type operator()(const T2DImage<T>& image) const; 
private:
  double m_threshold; 
}

C2DTreshholdFilter::C2DTreshholdFilter(double threshold):
  m_threshold(threshold)
{
}

template <typename T> 
typename C2DTreshholdFilter::result_type 
operator()(const T2DImage<T>& image) const
{
  auto r = new C2DBitImage(image.get_size(), image); 
  P2DImage result(r); 
  std::transform(image.begin(), image.end(), r->begin(), 
                 [m_threshold](T x){return x >= m_threshold;});
  return  result; 
}
\end{lstlisting}
\caption{\label{list:filterthreshold}Thresholding filter}
\end{listing}


To call such a filter in order to process an image \texttt{image} of type \texttt{C2DImage} 
   the following code is used: 
\begin{lstlisting}
  C2DTreshholdFilter filter(thresh); 
  auto filtered = mia::filter(filter, image); 
\end{lstlisting}


  
\subsection{Pixel Type Dependant Filtering}
\label{sec:ptdf}

In some cases, filters may be defined only for certain input pixel types, or one wants to apply 
   the filter differently depending of the actual pixel type. 
In these cases (partial) template specialization should be used. 

E.g. in the above example, using the thresh-holding filter on a bit-valued image doesn't make much sense. 
Therefore, we would like to report an error, if the filter is invoked with an bit valued image. 
This can be done  by additionally implementing a specialisation of the 
  operator () of \texttt{C2DTreshholdFilter}: 
\emph{I think another indirection is needed here ...}
\begin{lstlisting}{ThresholdFilterExample}
template <>
C2DTreshholdFilter::result_type C2DTreshholdFilter::operator(const C2DBitImage& image)const 
{
  throw invalid_argument("C2DTreshholdFilter can not be used on bit-valued images"); 
}
\end{lstlisting}
 
The compiler will take care of the rest, and if the user provides a bit valued image the 
  above exception will be thrown. 
For a further introduction into (partial) template specialization see, e.g.  
  \citet{vandevoorde05}.

Also note, that the implementation of \texttt{std::vector<bool>} uses bit field to represenet entries 
  and it is, therefore, often necessary to provide specializations to filters for this type.  


\section{Extending MIA}
\label{ch:extending}

One of the primary reasons for the plug-in based design of the library was to make it easy to extend 
  the funcionality of the library without altering the core libraries.




\subsection{Adding a Plugin to store/load data in a new file format}
\label{sec:newfilehandler}

In the following, adding support fo a new 2D image file format is described. 
The base class defining the interface for 2D Image IO is \texttt{C2DImageIOPlugin} and it is 
  declared in the the header file \texttt{<mia/2d/2dimageio.hh>}. 
In order to implement the new IO file format, four abstract virtual functions have to be implemented: 
\begin{itemize}  
\item {\tt do\_add\_suffixes}: Adds the standard suffixes for this file format to the plugin handlers suffic map. 
\item {\tt do\_load}: Implements loading data from the file. 
\item {\tt do\_save}: Implements storing data to the file. 
\item {\tt do\_get\_descr}: Returns a string with a short description of the plugin.
\end{itemize}  
In addition, a constructor has to be defined, in order to name the format. 

The following example code is taken from the Windows BMP iamge format IO plugin which resides in the MIA source tree in \texttt{mia/2d/io/bmp.cc}.
First, the plugin class is declared as a specification of the general 2D plugin class: 

\begin{lstlisting}{BMPIO}
#include <mia/2d/2dimageio.hh>
NS_BEGIN(BMPIO)
NS_MIA_USE

class CBMP2DImageIO: public C2DImageIOPlugin {
public:
  CBMP2DImageIO();
private: 
  void do_add_suffixes(multimap<string, string>& map) const;
  PData do_load(const string& fname) const;
  bool do_save(const string& fname, const Data& data) const;
  const string do_get_descr() const; 
};
\end{lstlisting}

\noindent 
The constructor of the plugin takes care of two things: initialise the plug-in with its apropriate name and set the supported pixel formats. 

\begin{lstlisting}{BMPIO}
CBMP2DImageIO::CBMP2DImageIO():
	C2DImageIOPlugin("bmp")
{
	add_supported_type(it_ushort);
	add_supported_type(it_ubyte); 
	add_supported_type(it_bit);
}
\end{lstlisting}

\noindent 
Since at construction time, nothing is known about the plugin handler, 
  the setup of the suffix-fileformat map has to be done in an extra function: 
\begin{lstlisting}{BMPIO}
void CBMP2DImageIO::do_add_suffixes(multimap<string, string>& map) const
{
	map.insert(pair<string,string>(".bmp", get_name())); 
	map.insert(pair<string,string>(".BMP", get_name())); 
}
\end{lstlisting}

\noindent 
The next function just gives a plain text description of the plug-in, that might be used when printing out help. 
\begin{lstlisting}{BMPIO}
const string  CBMP2DImageIO::do_get_descr()const
{
	return string("BMP 2D-image input/output support");
}
\end{lstlisting}

\noindent 
Since some file types (like, e.g. TIFF) provide their own routines for opening the file, this file open code 
  needs to be added here.
After creating the result image vector, format specific code follows to load the image data that is then returned. 
\begin{lstlisting}{BMPIO}
CBMP2DImageIO::PData CBMP2DImageIO::do_load(string const& filename)const
{
  int read = 0; 
  CInputFile f(filename);
  if (!f)
    return PData(); 

  PData result = PData(new C2DImageVector()); 

 
  // File format specific implementation follows
  //  ...
	
  return result; 
}
\end{lstlisting}

\noindent 
In the save function, again the file needs to be opened/created for output, because this might be format specific. 
Saving the image data requires a translation of the pixel type that is best provided by a filter 
  function (see Section \ref{sec:filter}) here given by the CImageSaver class.
\begin{lstlisting}{BMPIO}
bool CBMP2DImageIO::do_save(string const& filename, const C2DImageVector& data) const
{
	cvdebug() << "CBMP2DImageIO::save begin\n"; 
	
	COutputFile f(filename);
	if (!f) {
		cverr() << "CBMP2DImageIO::save:unable to open output file:" << filename << "\n"; 
		return false; 
	}
		
	CImageSaver saver(f); 
	
	for (C2DImageVector::const_iterator iimg = data.begin(); iimg != data.end(); ++iimg)
		filter(saver, **iimg); 
	
	cvdebug() << "CBMP2DImageIO::save end\n"; 
	return true; 
}
\end{lstlisting}

\noindent 
Finally, the plugin interface function needs to be defined. 
This functions needs to be declared \texttt{extern ``C''} to avoid the C++ name mangeling that is compiler dependend. 
Depending on the target platform and compiler, some additional decoration might be necessary that is set elsewhere 
  through the \texttt{EXPORT} define.
\begin{lstlisting}{BMPIO}
extern "C" EXPORT CPluginBase *get_plugin_interface()
{
		return new CBMP2DImageIO;
}
\end{lstlisting}

\noindent 
Above code skeleton provides the basis for all IO plugins. 
For further reading, please turn to the source code in the respective ``io'' directories.

\subsection{Writing a Factory Plugin}
\label{ch:filterplugin}

Most plug-ins in MIA are factory plug-ins, that provide an interface to create objects from certain 
  parameters that are usually given as strings. 
As an example we will describe a 2D filter plug-in that evaluates the mean intensity of a 
  pixel neighbourhood, called \texttt{mean}. 

All factory plug-ins are created using three files: \texttt{test\_plugin.cc}, \texttt{plugin.cc}, 
  and \texttt{plugin.hh}. 

These files are dedicated to 
\begin{description}
\item [test\_plugin.cc:] The unit-tests for the plug-in. 
\item [plugin.hh:] declarations of the filter and plug-in classes. 
\item [plugin.cc:] implementation of the filter and plug-in classes. 
\end{description}

MIA targets at a software development method that results in reliable software, and therefore,  
 for each plug-in unit-tests should be provided that ensure that the plug-in works as expected. 

In the following we assume that the newly created plugin will reside in \texttt{mia/2d/filter}. 
for the filter and the plug-in the interface is usually already defined completely by the according base-class
 and only the blanks need to be filled in - which means the pure virtual methods must be 
  overridden and implemented.
Accordingly, the header file \texttt{mean.hh} looks like follows: 

First, include the required header
\lstset{numbers=left,firstnumber=auto}
\begin{lstlisting}{MeanFilterHeader}
#include <mia/2d/2dfilter.hh>
\end{lstlisting}
and start the namespace for the filter: 
\begin{lstlisting}{MeanFilterHeader}
NS_BEGIN( mean_2dimage_filter)
\end{lstlisting}
It is best to put the code of each plug-in into its own, unique name space in oder to avoid 
  name collisions that may result into the wrong code being executed - an error that is quite 
  difficult to pin-point since it is very unexpected. 
Since the programs all access the plug-ins through the interface of the according base class this 
  separation of plug-in code into unique name-spaces doesn't put an additioal burden on the library consumers. 


Then follows the declaration of the actual filter: 
\begin{lstlisting}{MeanFilterHeader}
class C2DMean : public mia::C2DFilter {
public:
	C2DMean(int hw);

	template <class T>
	typename C2DMean::result_type operator () (const mia::T2DImage<T>& data) const;
private:
	virtual mia::P2DImage do_filter(const mia::C2DImage& image) const;

	int m_hw;
};
\end{lstlisting}
As one can see, \texttt{C2DMean} is derived from \texttt{mia::C2DFilter}, which is the base class 
  for all 2D filters.  
Line three declares the constructor and line eight the filter function that will call 
  \texttt{mia::filter}.
Unfortunatly, in C++ it is not possible to declare and define virtual template methods. 
Therefore, \texttt{do\_filter} has to be implemented within the actual filter that will 
  be used as parameter to \texttt{mia::filter} to run the \texttt{operator ()} according 
  to the pixel type the input image carries. 
The actual filter operator \texttt{operator ()} is declared as public function to simplify 
  the access permissions within \texttt{mia::filter}. 

The actual plug-in class is then declared like follows: 
\begin{lstlisting}{MeanFilterHeader}
class C2DFilterPluginFactory: public mia::C2DFilterPlugin {
public:
	C2DFilterPluginFactory();
private:
	virtual mia::C2DFilterPlugin::ProductPtr do_create()const;
	virtual const std::string do_get_descr()const;
	int m_hw;
};
\end{lstlisting}

The implementation of the filter is then very streightforward: 
\begin{lstlisting}{MeanFilterCode}

\end{lstlisting}





In the case of a mean filter, the test would look like this: 

First include the test framework and the header belonging to the actual filter: 
\lstset{numbers=left,firstnumber=auto}
\begin{lstlisting}{MeanFilterExample}
#include <mia/internal/autotest.hh>
#include <mia/2d/filter/mean.hh>
\end{lstlisting}

\noindent
Then we add the required {\bf using} statements to save us some typing
\begin{lstlisting}{MeanFilterExample}
NS_MIA_USE
using namespace std;
using namespace ::boost;
using namespace ::boost::unit_test;
using namespace mean_2dimage_filter;
\end{lstlisting}

Finally, we implement the test itself: 
\begin{lstlisting}{MeanFilterExample}
BOOST_AUTO_TEST_CASE( test_2dfilter_mean )
{
	const size_t size_x = 7;
	const size_t size_y = 5;

	const int src[size_y][size_x] =
		{{ 0, 1, 2, 3, 2, 3, 5},
		 { 2, 5, 2, 3, 5, 3, 2},
		 { 1, 2, 7, 6, 4, 2, 1},
		 { 3, 4, 4, 3, 4, 3, 2},
		 { 1, 3, 2, 4, 5, 6, 2}};

	// "hand filtered" w = 1 -> 3x3 using zero boundary conditions 
        //
	const float src_ref[size_y][size_x] =
        {{ 2.0/1.0,  2.0/1.0, 8.0/3.0, 17.0/6.0, 19.0/6.0, 10.0/3.0, 13.0/4.0},
         {11.0/6.0, 22.0/9.0,31.0/9.0, 34.0/9.0, 31.0/9.0,  3.0/1.0,  8.0/3.0},
         {17.0/6.0, 10.0/3.0, 4.0/1.0, 38.0/9.0, 11.0/3.0, 26.0/9.0, 13.0/6.0},
         { 7.0/3.0,  3.0/1.0,35.0/9.0, 13.0/3.0, 37.0/9.0, 29.0/9.0,  8.0/3.0},
         {11.0/4.0, 17.0/6.0,10.0/3.0, 11.0/3.0, 25.0/6.0, 11.0/3.0, 13.0/4.0}}; 

	C2DBounds size(size_x, size_y);

	C2DFImage *src_img = new C2DFImage(size);
	for (size_t y = 0; y < size_y; ++y)
		for (size_t x = 0; x < size_x; ++x)
			(*src_img)(x,y) = src[y][x];

	C2DMean mean(1);

	P2DImage src_wrap(src_img);

	P2DImage res_wrap = mean.filter(*src_wrap);

	C2DFImage* res_img = dynamic_cast<C2DFImage*>(res_wrap.get());
	BOOST_REQUIRE(res_img);
	BOOST_REQUIRE(res_img->get_size() == src_img->get_size());


	for (size_t y = 0; y < size_y; ++y)
		for (size_t x = 0; x < size_x; ++x)
			BOOST_CHECK_EQUAL((*res_img)(x,y), src_ref[y][x]);
}
\end{lstlisting}







\subsection{Adding a new general plugin type}
\label{ch:addpluginstype}

\subsection{Adding new data types}
\label{sec:adddatatypeio}


\bibliographystyle{plainnat}
\cleardoublepage\addcontentsline{toc}{chapter}{\bibname}
\bibliography{userguide}
\end{document}