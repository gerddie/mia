\section{2D CST filter kernels}   \label {sec:cst2dkern}
   
   These are kernels for filters that work in the frequency domain on the 
   image that was transformed by a cosinus or a sinus transform. 

\section{2D FFT filter kernels}   \label {sec:fft2dkern}
   
   These are kernels for filters that work in the frequency domain on the 
   Fourier transformed image. 

\section{2D Transformations}  \label{sec:2dtransforms}
  
  2D transformations provide to means to transform images and point sets. They are mostly used 
  in image registration. 
  
  
   \subsection{Affine}
   \label{transform2d:affine}
   
   \begin{description}
   
   \item [Plugin:] affine
   \item [Description:] Affine-linear transformations - i.e. the transformation cann be described in terms of a 
   multiplication by a $2\times2$ matrix $A$ and the addition of a translation vector $b$: 
   \begin{equation}
   x \rightarrow Ax + b
   \end{equation}
   
   \item [Degrees of Freedom:] 6 
  
   \end{description}
   This plug-in doesn't take parameters 

   
   \subsection{B-spline based transformation}
   \label{transform2d:spline}
   
   \begin{description}
   
   \item [Plugin:] spline
   \item [Description:] This plug-in implements a free-form transfromation that can be described by 
   a set of B-spline coefficients and an underlying B-spline kernel. 
   \item [Degrees of Freedom:] depends on the coefficient rate and the size of the domain where the 
      transformation is defined on 
  
   \end{description}

   \plugtabstart
   interp & string & interpolating B-spline kernel (bsplineX, omoms3) with X the degree (2-5)& bspline3 \\ 
   rate   & float  & coefficient rate (currently the same in all dimenions & 10 \\
   \plugtabend

   
   \subsection{Rigid}
   \label{transform2d:rigid}
   
   \begin{description}
   
   \item [Plugin:] rigid
   \item [Description:] Rigid transformations - i.r. rotations and translations are allowed. 
   \item [Degrees of Freedom:] 3 
  
   \end{description}
   This plug-in doesn't take parameters 

   
   \subsection{Translation}
   \label{transform2d:translate}
   
   \begin{description}
   
   \item [Plugin:] translate
   \item [Description:] Translation only.  
   \item [Degrees of Freedom:] 2
  
   \end{description}
   This plug-in doesn't take parameters 

   
   \subsection{Vectorfield}
   \label{transform2d:vf}
   
   \begin{description}
   
   \item [Plugin:] vf
   \item [Description:] This plug-in implements a transformation that defines a translation for 
                        each point of the grid defining the domain of the transformation. 
   \item [Degrees of Freedom:] with the grid size $(n_x,n_y)$: $2* nx * ny$
  
   \end{description}
   This plug-in doesn't  take parameters. 

\section{2D full cost functions}  \label{sec:2dfullcost}
  
  This class of cost functions evaluates the cost resulting from the 
  use of a certain transformation. This may include a penalty term that ensures 
  the smoothness of a transformation or the evaluation of a similarity measure 
  between a transformed study data set and a refernce data set. 
  
  These cost functions can be combined and weighted. 
  

      
   \subsection{DivCurl smoothing measure}
   \label{fullcost2d:divcurl}
   
   \begin{description}
   
   \item [Plugin:] divcurl
   \item [Description:] Evaluate the DivCurl measure of a given transformation $T$. 

   \begin{equation}
   F_{\text{divcurl}} := \int_{\Omega} w_{\text{div}}\left\| \nabla \nabla  \cdot (T(\vx)) \right\|^2  + 
                                       w_{\text{curl}}\left\| \nabla \curl(T(\vx)) \right\|^2 d\vx.
   \end{equation}
   
   \plugtabstart
   weight &  float & all-over weight of the cost function & 1.0  \\
   div &  float & weight $w_{\text{div}}$ of the divergence part of the transformation & 1.0  \\
   curl &  float & weight $w_{\text{curl}}$ of the rotation part of the transformation  & 1.0  \\
   \plugtabend
   
   \item [Remark:] Using this cost function only makes sense for spline based transformations  
             \ref{transform2d:spline} with spline degree 3 or higher, or densely defined 
             transfromations \ref{transform2d:vf}
   \end{description}


      
   \subsection{Image cost function}
   \label{fullcost2d:image}
   
   \begin{description}
   
   \item [Plugin:] image
   \item [Description:] Evaluate the image similarity measure of a cost function 

  
   \plugtabstart
   weight &  float & all-over weight of the cost function & 1.0  \\
   src & string & the study (or floating) image & src.@ \\
   ref & string & the reference (or fixed) image & ref.@ \\
   cost & string & Description of the image similarity measure kernel (\ref{sec:cost2d} & ssd \\
   interp & string & Image interpolator kernel & bspline3 \\
   debug & bool & Save intermediate resuts for debugging (creates a lot of data)  & false \\
   \plugtabend
   
   \item [Remark:] The default parameters for the src and ref image are used for passing 
                   the data within the program. Don't change these parameters unless you know
		   what you are doing.  
   \end{description}

\section{2D image combiner}  \label{sec:combiner2d}
  
  2D image combiners take two constant references to a C2DImage as parameter and 
  return the result in a shared\_ptr P2DImage. 
  After constructions, combinerss work like functions, i.e. the output image is only dependent 
  on the input images and the construction parameters. 

  Combiners are created by the C2DImageCombinerPluginHandler singleton. 

   
   \subsection{Arithmetic image combiners}
   \label{combiner2d:aritmetic}
   
   \begin{description}
   
   \item [Plugin:] add, sub, mul, div, absdiff
   \item [Description:] combine the two images by applying the corresponding arithmetic operaton. 
   The input images must be of the same size. 
   \item [Input1:] Abitrary gray scale or binary image 
   \item [Input2:] Abitrary gray scale or binary image 
   \item [Output:] The combined image of the pixel type that is deducted from the 
                   C++ return type for the corresponding operation between the input pixel types.
   \item [Remark:] No special error handling is implemented for the division by zero.  
   \end{description}
   These plug-ins don't take additional parameters

\section{2D image creators}  \label{sec:creator2d}
  
  These plug-ins create 2D imgages with predefined objects inside. 


  \subsection{Circle creator}
  \label{creator2d:circle}
   
  \begin{description}
   
  \item [Plugin:] circle
  \item [Description:] Creates an image with a filled shape. The filling pattern is 
         given bythe parameters. 
   
   \plugtabstart
   f & float & spherical change frequency & 1.0 \\
   p & float & spherical shape parameter (2.0 = circle)& 2.0 \\
   \plugtabend
   
   \end{description}


\section{2D image filters}  \label{sec:filter2d}
  
  2D image filters take a constant reference to a C2DImage as parameter and 
  return the result in a shared\_ptr P2DImage. 
  After constructions, filters work like functions, i.e. the output image is only dependent 
  on the input image and the construction parameters. 
  
  Filters are created by the C2DFilterPluginHandler singleton.


  \subsection{Adaptive mean filter}
  \label{filter2d:admean}
  
  \begin{description}
  
  \item [Plugin:] admean
  \item [Description:] An adaptive mean filter that works like a normal mean filter, if the intensity 
        variation within the filter mask is lower then the intensity variation in the whole image, 
	that the uses a special formula if the local variation is higher then the image intensity variation.
  \item [Input:] Abitrary gray scale image 
  \item [Output:] The filtered image of the same pixel type and dimension 
  
  \plugtabstart
  w &  int & filter width parameter & 1  \\
  \plugtabend
  
  \end{description}


  \subsection{Adaptive median filter}
  \label{filter2d:adaptmed}
  
  \begin{description}
  
  \item [Plugin:] adaptmed
  \item [Description:] An adaptive median filter that works like follows: 

  \begin{itemize}
    \item filter width is w=2*n+1
    \item start with n=1
    \begin{itemize}
      \item  if the resulting filtered value is equal to the min or max of the covered
             area (max or min) then increase n and repeat filtering
      \item  repeat above algorithm until n=n\_max or resulting value is not equal to an
             extreme value
    \end{itemize}     
    \item if the original intensity value of the image is equal to one of the extremes,
          then keep the value, otherwise replace it by the filter result
  \end{itemize}

  \item [Input:] Abitrary gray scale image 
  \item [Output:] The filtered image of the same pixel type and dimension 
  
  \plugtabstart
  w &  int & maximum filter width parameter & 2  \\
  \plugtabend
  
  \item [Remark:] for bit valued images this is just the normal median filter applied with the maximum filter width.
  
  \end{description}


  \subsection{Anisotropic filtering}
  \label{filter2d:aniso}
  
  \begin{description}
  
  \item [Plugin:] aniso
  \item [Description:] Run a anisotropic filter on the input image 
  \item [Input:] Abitrary gray scale image 
  \item [Output:] The filtered image of the same pixel type and dimension 
  
  \plugtabstart
  iter & int & maximum number of iterations & 100 \\
  epsilon & float & stop iteration if changes fall below this value & 1.0  \\
  k & float & k the noise threshold ($\le 0$: adaptive) & -1 \\
  psi & string & Edge stopping funtion (ps1|ps2|tuckey|guess) & - \\
  n & int & neighbourhood shape (4|8) &  8 \\
  \plugtabend
  
  \item [Remark:] For mor information see \cite{perona90:aniso}. 
  
  \end{description}

   
   \subsection{Bandpass intensity filter}
   \begin{description}
   \item [Plugin:]bandpass
   \item [Description:]An intensity band pass filter - all pixels with intensities
   outside the given range are set to zero, all other pixels remain the
   same ($x:=x\in [min,max]\:?\: x\::\:0$
   \item [Parameters:] min, max
   
   \plugtabstart
   min&  float&  lower bound of the bandpass range &0\\\hline
   max&  float&  upper bound of the bandpass range &3.40282e+38\\\hline
   \end{tabular}
   \end{description}
   

   \subsection{Binarize Filter}
   \begin{description}
   \item [Plugin:]binarize
   \item [Description:]An binarize filter - all pixels with intensities
   outside the given range are set to zero, all other pixels are set to one
   same ($x:=x\in [min,max]\:?\: x\::\:0$
   \item [Parameters:] min, max
   
   \plugtabstart
   min&  float&  lower bound of the intensity range &0\\\hline
   max&  float&  upper bound of the intensity range &3.40282e+38\\\hline
   \end{tabular}
   \end{description}
   
   
   \subsection{Downscale filter}
   \label{filter2d:downscale}
   
   \begin{description}
   
   \item [Plugin:] downscale
   \item [Description:] Downscale the input image by using a given block size to define the 
            downscale factor. Prior to scaling the image is filtered by a smoothing filter to eliminate 
	    high frequency data and avoid aliasing artifacts. 
   \item [Input:] Abitrary gray scale or binary image 
   \item [Output:] The downscaled image.  
   
   \plugtabstart
   bx & int & downscale factor in x direction & 1  \\
   by & int & downscale factor in y direction & 1  \\
   b & string & Alternative to define the scaling factors as a 2D vector & <1,1>  \\
   kernel & string & Base type of the smoothing kernel, the filter kernel width is estimated based 
       on the downscale factors & gauss \\\hline 
   \plugtabend
   
   \end{description}

   
   \subsection{Image cropping}
   \label{filter2d:crop}
   
   \begin{description}
   
   \item [Plugin:] crop
   \item [Description:] Crop a region of an image, the region is always clamped to the original image size. 
   \item [Input:] Abitray grayscale image 
   \item [Output:] A gray scale image that contains the cropped region. 
   
   \plugtabstart
   start & 2D vector & upper left corner of the requested sub-region  & <0,0>  \\
   end & 2D vector & lower right corner of the requested sub-region, a value of -1 refers the size of the 
      original image in that dimension  & <-1,-1>  \\
   \plugtabend
   
   \end{description}

   
   \subsection{Intensity invert}
   \label{filter2d:invert}
   
   \begin{description}
   
   \item [Plugin:] invert
   \item [Description:] invert the image intensities. Inversion of an image $I$ is done by a linearly mapping using 
     $\forall x \in I: x \rightarrow (\max(I) - x + \min(I))$ 
   
   \item [Input:] A gray scale image of abitrary pixel type. 
   \item [Output:] The inverted image 
   
   \end{description}
   
   This plug-in doesn't take parameters. 

   
   \subsection{K-means classification}
   \label{filter2d:kmeans}
   
   \begin{description}
   
   \item [Plugin:] kmeans
   \item [Description:] Apply a k-means classification to the image 
   \item [Input:] A gray scale image of abitrary pixel type. 
   \item [Output:] The classification image, the class centers are saved as image attribute
   
   \plugtabstart
   c &  int & The number of classes ($\le$ 255) & 5  \\
   \plugtabend

   \end{description}

   
   \subsection{Label connected components}
   \label{filter2d:label}
   
   \begin{description}
   
   \item [Plugin:] label
   \item [Description:] Label connected components 
   \item [Input:] Binary image 
   \item [Output:] An image of type unsigned char or unsigned short, depending on the number of components found. 
                  The first label is 1
   
   \plugtabstart
   shape &  string & neighbourhood shape as provided by the shape plug-ins \ref{sec:2dshapes} & 4n  \\
   \plugtabend
   
   \item [Remark:] A maximum of 65535 labels is supported. 

   \end{description}

   
   \subsection{Mean Least Variance filter}
   \label{filter2d:mlv}
   
   \begin{description}
   
   \item [Plugin:] mlv
   \item [Description:] Apply the mean least variance filter. 
   \item [Input:] Abitrary gray scale or binary image 
   \item [Output:] The filtered image of the same pixel type and dimension 
   
   \plugtabstart
   w &  int & filter width parameter & 1  \\
   \plugtabend
   
   \end{description}

   
   \subsection{Median filter}
   \label{filter2d:median}
   
   \begin{description}
   
   \item [Plugin:] median
   \item [Description:] Apply the median filter. 
   \item [Input:] Abitrary gray scale or binary image 
   \item [Output:] The filtered image of the same pixel type and dimension 
   
   \plugtabstart
   w &  int & filter width parameter & 1  \\
   \plugtabend
   
   \end{description}

   
   \subsection{Morphological filters}
   \label{filter2d:morph}
   
   \begin{description}
   
   \item [Plugin:] dilate, erode, close, open
   \item [Description:] Apply the according morphological operation using a given structuring element 
   \item [Input:] Abitrary gray scale or binary image 
   \item [Output:] The filtered image of the same pixel type and dimension 
   
   \plugtabstart
   shape &  string & definition of the structuring element as provided by the shape plugins \ref{sec:2dshapes} & 
         sphere:r=2    \\
   hint  &  string & A hint to speed up the processing of binary images (black|white), should indicate 
         what kind of pixel is more presnt in the image  & black \\\hline 
   \plugtabend
   
   \end{description}

   
   \subsection{Norm of a gradient of the image}
   \label{filter2d:gradnorm}
   
   \begin{description}
   
   \item [Plugin:] gradnorm
   \item [Description:] This filter evaluates the norm of the gradient of the input image
   \item [Input:] An abitrary gray scale image. 
   \item [Input:] The norm of the gradient of the input image as a single float valued 
             image normalized to the range [-1, 1]. 
   
   \end{description}
   This plugin doesn't take parameters. 

   
   \subsection{Norm of a normalized gradient field of the image}
   \label{filter2d:ngfnorm}
   
   \begin{description}
   
   \item [Plugin:] ngfnorm
   \item [Description:] This filter evaluates the norm of a normalized gradient field of the input image
   \item [Input:] An abitrary gray scale image. 
   \item [Input:] The norm of the normalized gradient field of the input image as a single float valued 
             image of the same dimension as th einput image. 
   
   \end{description}
   This plugin doesn't take parameters. 

   
   \subsection{Pixel value conversion}
   \label{filter2d:convert}
   
   \begin{description}
   \item [Plugin:]convert
   \item [Description:] Pixel conversion filter
   \item [Conversions:] Mapping methods 
   \begin{description}
   \item [copy:] pixel values are copied, values outside of the target range are clipped
   \item [linear:] pixel values are transformed according to $x \rightarrow a \times x + b$ , 
       values outside of the target range are clipped
   \item [opt:] The range of the input pixels \emph{found in the input image} 
       is mapped to the range of the output type. 
   \item [range:] The range of the input pixel \emph{type} is mapped to the range of the output type. 
   \end{description}
   \item [Parameters:] a, b, map, repn
   
   \plugtabstart
   a&  float&  scaling for linear mapping & 1.0\\\hline
   b&  float&  shift of linear mapping    & 0.0\\\hline
   map& string & type of mapping (copy|linear|opt|range) & opt\\\hline
   repn & string & target pixel type ( sbyte | ubyte | sshort | ushort |
				sint | uint | slong | ulong | float | double) & ubyte \\\hline
   \plugtabend
   
   \end{description}

   
   \subsection{Run a filter in the frequency domain}
   \label{filter2d:fft}
   
   \begin{description}
   
   \item [Plugin:] fft
   \item [Description:] Run a filter in the frequency domain by applying a forward real2complex fft, 
         running the filter, and applying the backward complex2real fft. 
   \item [Input:] Abitrary gray scale or binary image 
   \item [Output:] The filtered image of the same pixel type and dimension 
   
   \plugtabstart
   k & string & filter kernel as provided by the 2D fft kernel plugin handler \ref{sec:fft2dkern} &   \\
   \plugtabend
   
   \item [Remark:] Currently, no kernels are implemented. 
   
   \end{description}

   
   \subsection{Scaling filter}
   \label{filter2d:scale}
   
   \begin{description}
   
   \item [Plugin:] scale
   \item [Description:] A 2D image filter to scale images. 
   \item [Input:] An abitrary gray scale image. 
   \item [Input:] The scaled image with the same pixel type.  
   
   \plugtabstart
   sx & int & target width & 128 \\
   sy & int & target height & 128 \\
   interp & string & interpolation kernel descriptor & "bspline3" \\\hline 
   \plugtabend

   \item [Remark:] Currently downscaling is not handled correctly. 
   
   \end{description}

   
   \subsection{Select biggest component}
   \label{filter2d:selectbig}
   
   \begin{description}
   
   \item [Plugin:] selectbig
   \item [Description:] A 2D filter that creats a binary mask representing the intensity with the highest pixel count. 
   The pixel value 0 will be ignored, and if two intensities have the same pixel count, then the result is undefined. 
   \item [Input:] An image with integral intensity values, usually this will be the output of the 
         label filter \ref{filter2d:label}. 
   \item [Input:] An binary image with a mask that represents the pixels with the highest pixel count. 

   This plug-in takes no parameters. 
   
   \end{description}

   
   \subsection{Spacial separable convolution filter}
   \label{filter2d:sepconv}
   
   \begin{description}
   
   \item [Plugin:] sepconv
   \item [Description:] A 2D image filter that runs separable ove each dimension 
   \item [Input:] Abitrary gray scale image 
   \item [Output:] Filtered gray scale image of the same pixel type and dimension
   
   \plugtabstart
   kx &  string & Filter kernel in x-direction as available through the spacial kernel plug-ins \ref{sec:SpacialKernels}
      & gauss:w=1    \\
   ky &  string & Filter kernel in y-direction as available through the spacial kernel plug-ins \ref{sec:SpacialKernels}
      & gauss:w=1    \\\hline 
   \plugtabend
   
   \end{description}

   
   \subsection{Threshhold filter with neighbourhood preservation}
   \label{filter2d:thresh}
   
   \begin{description}
   
   \item [Plugin:] thresh
   \item [Description:] set a pixel value to zero if all neighborhood values are below a given threshhold 
   \item [Input:] Abitrary gray scale image 
   \item [Output:] Filtered gray scale image of the same pixel type and dimension

   \plugtabstart
   shape &  string & neighbourhood shape as available through the shape plugins \ref{sec:2dshapes} & 4n \\
   thresh&  float  & threshhold value & 5.0\\\hline
   \plugtabend
   
   \end{description}

\section{2D image similarity kernels}  \label{sec:cost2d}
  
  2D image similarity kernels evaluate the according similarity measure between 
  two images. These kernels may be used standalone, like e.g. in linear registration, 
  or will be called from generalized image similarity cost plug-ins that also take 
  care of transforming and scaling the images during the image registration process. 

  In the following $\Omega$ is the image domain, and $S:\Omega\rightarrow \R$ stands  
  for the study or floating image, and  $R:\Omega\rightarrow \R$ for the reference or fixed image. 

   
   \subsection{Least Squares Difference}
   \label{cost2d:lsd}
   
   \begin{description}
   
   \item [Plugin:] lsd
   \item [Description:] Evaluates the Least Squares Difference similarity measure between two images 
   \cite{heldmann10lsd}
   \item [Study:] An abitrary gray scale or binary images 
   \item [Reference:] A gray scale or binary images that should have a limited number of gray scale values 
                 and a histogram that is not too close to a uniform distribution. 
   \end{description}
   
   This plug-in doesn't take additional parameters. 

   
   \subsection{Normalized Gradient Fields}
   \label{cost2d:ngf}
   
   \begin{description}
   
   \item [Plugin:] ngf
   \item [Description:] This function evaluates the image similarity based on normalized gradient 
                        fields. Given normalized gradient fields $\n_S$ of the study image and $\n_R$
			of the reference image various evaluators are implemented: 
   \begin{itemize}
   \item cross Cross product based formulation: 
     \begin{equation}
       F_{\text{ngf}, \times}(\n_S, \n_R) := \frac{1}{2}\int_{\Omega} \left( \n_S(x) \times \n_R(x) \right)^2 \text{d}x
     \end{equation}
   \item dot Dot product based formulation: 
     \begin{equation}
        F_{\text{ngf}, \cdot}(\n_S, \n_R) := \frac{1}{2}\int_{\Omega} \left( \n_S(x) \cdot \n_R(x) \right)^2 \text{d}x
      \end{equation}
   \item sq 
     \begin{equation}
   	F_{\text{ngf}, \Delta^2} := \frac{1}{2}  \int_\Omega  
	\left(<\n_R(x),\n_S(x)>^2   - \| \n_R(x)\|^2 \right)^2  \text{d}x,
     \end{equation}
   \item ds 
     \begin{equation}
   	F_{\text{ngf}, \cdot\Delta} := \frac{1}{2}  \int_\Omega  
	\left( \| \n_R(x)\|^2 -
        \frac{<\n_R(x),\n_S(x)>^2}{\|\n_R(x)\|\|\n_S(x)\|} \right)^2  \text{d}x,
      \end{equation}
   \end{itemize}

   \item [Study:] An abitrary gray scale or binary images 
   \item [Reference:] An abitrary gray scale or binary images 
   
   \end{description}
   
   \plugtabstart
   eval &  strimng & Evaluator (cross|dot|ds|sq) & ds  \\
   \plugtabend

   For further information see \cite{haber05, wollny08a, wollny10b}. 

   
   \subsection{Sum of Squared Differences}
   \label{cost2d:ssd}
   
   \begin{description}
   
   \item [Plugin:] ssd
   \item [Description:] Evaluates the Sum of Squared Differences similarity measure between two images:
   \begin{equation}
      F_\text{SSD} (S,R) = \frac{1}{2} \int_{\Omega} \left( S(x) - R(x) \right)^2 \text{d}x 
   \end{equation}
   \item [Study:] An abitrary gray scale or binary images 
   \item [Reference:] An abitrary gray scale or binary images 
   \end{description}
   
   This plug-in doesn't take additional parameters. 

\section{2D image stack filters}  \label{sec:fifof}
  
  These filters work on a stack of 2D images in a 3D manner by interpreting the images of the stack 
   as slices of a 3D image.
  For spacial filters with a fixed filter width that is small compared to the number of slices 
  the filter is applied in a true 3D manner. 
  Other filters, that would normaly require to work on the whole image domain at once, the 
  image filter is only applied to a subset of the images at a time 
  which results in a quasi-3D processing. 
  Only filters are supported that can be run in a single pass. 
  
  Filters are created by the C2DFifoFilterPluginHandler singleton.

   
   \subsection{Gaussian smoothing}
   \label{fifof:gauss}
   
   \begin{description}
   
   \item [Plugin:] gauss
   \item [Description:] Runs an isotropic Gaussian smothing filter on the imput images. 
   \item [Input:] Gray scale or binary images, all of the same size and pixel type  
   \item [Output:] The filtered image(s) 
   
   \plugtabstart
   w & int & filter width parameter, the actual filter captures a neighborhood of 
                 $(2 * w + 1) \times (2 * w + 1) \times (2 * w + 1)$ voxels & 1 \\ 
   \plugtabend
   
   \end{description}

   
   \subsection{Mean least variance}
   \label{fifof:mlv}
   
   \begin{description}
   
   \item [Plugin:] mlv 
   \item [Description:] Runs a mean least variance filter on the imput images. 
               The number of slices that are hold in the working memory is deducted from 
	       the filter size.
   \item [Input:] Gray scale or binary images, all of the same size and pixel type  
   \item [Output:] The filtered image(s) 
   
   \plugtabstart
   w & int & filter width parameter, the actual filter captures a neighborhood of 
                 $(4 * w + 1) \times (4 * w + 1) \times (4 * w + 1)$ voxels & 1 \\ 
   \plugtabend
   
   \end{description}

   
   \subsection{Median}
   \label{fifof:median}
   
   \begin{description}
   
   \item [Plugin:] median
   \item [Description:] Runs a median filter on the imput images. 
   \item [Input:] Gray scale or binary images, all of the same size and pixel type  
   \item [Output:] The filtered image(s) 
   
   \plugtabstart
   w & int & filter width parameter, the actual filter captures a neighborhood of 
                 $(2 * w + 1) \times (2 * w + 1) \times (2 * w + 1)$ voxels & 1 \\ 
   \plugtabend
   
   \end{description}

   
   \subsection{Morphological filters}
   \label{fifof:morph}
   
   \begin{description}
   
   \item [Plugin:] close, dilate, erode, open 
   \item [Description:] Runs the given morphological operation on the imput images. 
               The number of slices that are hold in the working memory is deducted from 
	       the given structuring element.
   \item [Input:] Gray scale or binary images, all of the same size and pixel type  
   \item [Output:] The filtered image(s) 
   
   \plugtabstart
   shape & string & Structuring element, as provided by by the shape plugins \ref{sec:3dshapes} & 6n \\ 
   \plugtabend
   
   \end{description}

   
   \subsection{Probability based region growing}
   \label{fifof:regiongrow}
   
   \begin{description}
   
   \item [Plugin:] regiongrow
   \item [Description:] Run a region-growing filter on a stack of images that comprise 
         a 3D image.  The region growing is based on class probabilities obtained from 
	 a c-means classification of the pixel intensities. 
	 Quasi-3D processing is achieved by holding a number of 3D slices in the working memory 
	 to allow the region to grow "backwards" in the stack. 
   \item [Input:] Gray scale images, all of the same size and pixel type  
   \item [Output:] A binary mask representing the region 
   
   \plugtabstart
   map & string & File name for the intensity--class probability map & -  \\
   seed  & float & Seed threshold, pixels with a class probablility above or equal to this value 
                    are used to seed the region growing & 0.98 \\
   low & float & probability threshold for the acceptance of a probability, 
                 during the region growing, pixels with a lower class probability are not 
                 added to the region & 0.5 \\
   depth & int & Number of slices to keep during processing. A smaller value 
                 saves working memory but also reduces the possibility 
                 for the region growing to grow backwards in the image stack & 5 \\
   class & int & class to be segmented, must be lower then the number of classes in the probability map  & 2 \\
   \plugtabend
   
   \end{description}

\section{2D model based registration}  \label{sec:regmodel2d}
  
  These plug-ins refer to non-linear registration approaches that use 
  a PDE based model for the regularization of the transformation. 


  \subsection{Identity}
  \label{model2d:identity}
  
  \begin{description}
   
  \item [Plugin:] identity
  \item [Description:] This plug-in provides an identity model that just copies the 
  input field to the output. 
  \end{description}
  This plug-in doesn't take extra parameters. 
  

  \subsection{Navier-Stokes PDE, Gauss-Southwell version}
  \label{model2d:naviera}
  
  \begin{description}
   
  \item [Plugin:] navier
   \item [Description:] This plug-in provides a version of the Navier-Stockes based 
   registration model that allow for linear-elastic or fluid dynamic registration models. 
   \begin{equation}
   \mu \nabla ^{2}\vu(\vx)+(\mu +\lambda )\nabla (\nabla \cdot \vu(\vx)) = -[S(\vx)-R(\vx)]\left. \nabla S\right| _{\vx}\ \
   \end{equation}
   
   The plug-in solves the underlying PDE by running a Gauss-Southwell relaxation. 
   For a version that uses Succesive Overrelaxation use \emph{navier}
   \ref{model2d:navier}.

   \plugtabstart
   mu & float & shear parameter $\mu$  & 1.0 \\
   lambda & float & dilation parameter $\lambda$  & 1.0 \\
   omega & float & relaxation parameter & 1.0 \\
   epsilon & float & stopping parameter & 0.0001 \\
   iter & int & maximum number of iterations & 100 \\
   \plugtabend

   \end{description}

						

  \subsection{Navier-Stokes PDE, SOR version}
  \label{model2d:navier}
  
  \begin{description}
   
  \item [Plugin:] navier
   \item [Description:] This plug-in provides a version of the Navier-Stockes based 
   registration model that allow for linear-elastic or fluid dynamic registration models. 
   \begin{equation}
   \mu \nabla ^{2}\vu(\vx)+(\mu +\lambda )\nabla (\nabla \cdot \vu(\vx)) = -[S(\vx)-R(\vx)]\left. \nabla S\right| _{\vx}\ \
   \end{equation}
   
   The plug-in solves the underlying PDE by running a full SOR algorithm. 
   For a version that uses a Gauss-Southwell relaxation use \emph{naviera}
   \ref{model2d:naviera}.

   \plugtabstart
   mu & float & shear parameter $\mu$  & 1.0 \\
   lambda & float & dilation parameter $\lambda$  & 1.0 \\
   omega & float & relaxation parameter & 1.0 \\
   epsilon & float & stopping parameter & 0.0001 \\
   iter & int & maximum number of iterations & 100 \\
   \plugtabend

   \end{description}

						
\section{2D neighborhood shapes}  \label{sec:2dshapes}
  
  These 2D shapes define neighbourhoods for a variety of image processing filters, 
  like, e.g., morphological filters \ref{filter2d:morph} or neighborhood aware threshholding \ref{filter2d:thresh}. 
  Shapes are always binary. 
  


  \subsection{Basic shapes}
  \label{shapes2d:basic}

  \begin{description}
   
   \item [Plugin:] 4n, 8n 
   \item [Description:] provide the simple neighbourhood shapes, 'o' indicates the center (that belongs to the shape) 
       and 'x' the additional elements. 
   \begin{itemize}
   \item 4n 
     \begin{tabular}{|c|c|c|}
     \hline 
     & x & \\
     \hline 
     x & o & x \\
     \hline 
     & x & \\
     \hline 
     \end{tabular}
   \item 8n 
     \begin{tabular}{|c|c|c|}
     \hline 
     x & x & x\\
     \hline 
     x & o & x \\
     \hline 
     x & x & x\\
     \hline 
     \end{tabular}
   \end{itemize}
   
   \end{description}
   These plug-ins don't take parameters. 
   


  \subsection{Spherical shape}
  \label{shapes2d:sphere}

  \begin{description}
   
   \item [Plugin:] sphere 
   \item [Description:] provide a 2D sphere like shape that includes its interior. 
   
   \end{description}
   \plugtabstart
   r &  float & radius of the sphere & 2 \\
   \plugtabend
   
\section{2D time steps for model based registration}  \label{sec:timestep2d}
  
  These plug-ins refer to non-linear registration approaches that use 
  a PDE based model for the regularization of the transformation.
  The plug-ins implement different time step models. 


  \subsection{Direct step}
  \label{timestep2d:direct}
  
  \begin{description}
   
  \item [Plugin:] direct
  \item [Description:] This time step plug-in implements a direct time-step where 
  the PDE of the registration model works directly on the transformation field. 

  \plugtabstart
  min & float & minimum time step allowed ($\ge 0.001$) & 0.1\\
  max & float & maximum time step allowed ($\ge 0.002$) & 0.1\\
  \plugtabend
  
  \end{description}
  

  \subsection{Fluid step}
  \label{timestep2d:fluid}
  
  \begin{description}
   
  \item [Plugin:] fluid
  \item [Description:] This time step plug-in implements a direct time-step where 
  the PDE of the registration model works on the velocity field. 

  \plugtabstart
  min & float & minimum time step allowed ($\ge 0.001$) & 0.1\\
  max & float & maximum time step allowed ($\ge 0.002$) & 0.1\\
  \plugtabend
  
  \end{description}
  
\section{3D Transformations}  \label{sec:3dtransforms}
  
  3D transformations provide to means to transform images and point sets. They are mostly used 
  in image registration. 
  
  
   \subsection{Affine}
   \label{transform3d:affine}
   
   \begin{description}
   
   \item [Plugin:] affine
   \item [Description:] Affine-linear transformations - i.e. the transformation cann be described in terms of a 
   multiplication by a $2\times2$ matrix $A$ and the addition of a translation vector $b$: 
   \begin{equation}
   x \rightarrow Ax + b
   \end{equation}
   
   \item [Degrees of Freedom:] 12
  
   \end{description}
   This plug-in doesn't take parameters 

   
   \subsection{B-spline based transformation}
   \label{transform3d:spline}
   
   \begin{description}
   
   \item [Plugin:] spline
   \item [Description:] This plug-in implements a free-form transfromation that can be described by 
   a set of B-spline coefficients and an underlying B-spline kernel. 
   \item [Degrees of Freedom:] depends on the coefficient rate and the size of the domain where the 
      transformation is defined on 
  
   \end{description}

   \plugtabstart
   interp & string & interpolating B-spline kernel (bsplineX, omoms3) with X the degree (2-5)& bspline3 \\ 
   rate   & float  & coefficient rate (currently the same in all dimenions & 10 \\
   \plugtabend

   
   \subsection{Rigid}
   \label{transform3d:rigid}
   
   \begin{description}
   
   \item [Plugin:] rigid
   \item [Description:] Rigid transformations - i.r. rotations and translations are allowed. 
   \item [Degrees of Freedom:] 6 
  
   \end{description}
   This plug-in doesn't take parameters 

   
   \subsection{Translation}
   \label{transform3d:translate}
   
   \begin{description}
   
   \item [Plugin:] translate
   \item [Description:] Translation only.  
   \item [Degrees of Freedom:] 3
  
   \end{description}
   This plug-in doesn't take parameters 

\section{3D full cost functions}  \label{sec:3dfullcost}
  
  This class of cost functions evaluates the cost resulting from the 
  use of a certain transformation. This may include a penalty term that ensures 
  the smoothness of a transformation or the evaluation of a similarity measure 
  between a transformed study data set and a refernce data set. 
  
  These cost functions can be combined and weighted. 
  

      
   \subsection{DivCurl smoothing measure}
   \label{fullcost3d:divcurl}
   
   \begin{description}
   
   \item [Plugin:] divcurl
   \item [Description:] Evaluate the DivCurl measure of a given transformation $T$. 

   \begin{equation}
   F_{\text{divcurl}} := \int_{\Omega} w_{\text{div}}\left\| \nabla \nabla  \cdot (T(\vx)) \right\|^2  + 
                                       w_{\text{curl}}\left\| \nabla \curl(T(\vx)) \right\|^2 d\vx.
   \end{equation}
   
   \plugtabstart
   weight &  float & all-over weight of the cost function & 1.0  \\
   div &  float & weight $w_{\text{div}}$ of the divergence part of the transformation & 1.0  \\
   curl &  float & weight $w_{\text{curl}}$ of the rotation part of the transformation  & 1.0  \\
   \plugtabend
   
   \item [Remark:] Using this cost function only makes sense for spline based transformations  
             \ref{transform3d:spline} with spline degree 3 or higher, or densely defined 
             transfromations \ref{transform3d:vf}
   \end{description}


      
   \subsection{Image cost function}
   \label{fullcost3d:image}
   
   \begin{description}
   
   \item [Plugin:] image
   \item [Description:] Evaluate the image similarity measure of a cost function 

  
   \plugtabstart
   weight &  float & all-over weight of the cost function & 1.0  \\
   src & string & the study (or floating) image & src.@ \\
   ref & string & the reference (or fixed) image & ref.@ \\
   cost & string & Description of the image similarity measure kernel (\ref{sec:cost3d} & ssd \\
   interp & string & Image interpolator kernel & bspline3 \\
   debug & bool & Save intermediate resuts for debugging (creates a lot of data)  & false \\
   \plugtabend
   
   \item [Remark:] The default parameters for the src and ref image are used for passing 
                   the data within the program. Don't change these parameters unless you know
		   what you are doing.  
   \end{description}

\section{3D image creators}  \label{sec:creator3d}
  
  These plug-ins create 3D imgages with predefined objects inside. 


  \subsection{Lattice Creator}
  \label{creator3d:lattic}
   
  \begin{description}
   
  \item [Plugin:] lattic
  \item [Description:] Creates an image with a lattic that has smooth boundaried 
   
   \plugtabstart
   fx & float & lattic pattern frequency & 16.0 \\
   fy & float & lattic pattern frequency & 16.0 \\
   fz & float & lattic pattern frequency & 16.0 \\
   \plugtabend
   
   \end{description}



  \subsection{Sphere Creator}
  \label{creator3d:sphere}
   
  \begin{description}
   
  \item [Plugin:] sphere
  \item [Description:] Creates an image with a filled distorted sphere-like shape. The shape and filling 
       patternare given by the parameters. 
   
   \plugtabstart
   f & float & spherical change frequency & 1.0 \\
   p & float & spherical shape parameter (2.0 = circle)& 2.0 \\
   \plugtabend
   
   \end{description}


\section{3D image filters}  \label{sec:3dfilters}
  
  3D image filters take a constant reference to a C3DImage as parameter and 
  return the result in a shared\_ptr P3DImage. 
  After constructions, filters work like functions, i.e. the output image is only dependent 
  on the input image and the construction parameters. 
  
  Filters are created by the C3DFilterPluginHandler singleton.


  \subsection{Anisotropic filtering}
  \label{filter3d:aniso}
  
  \begin{description}
  
  \item [Plugin:] aniso
  \item [Description:] Run a anisotropic filter on the input image 
  \item [Input:] Abitrary gray scale image 
  \item [Output:] The filtered image of the same pixel type and dimension 
  
  \plugtabstart
  iter & int & maximum number of iterations & 100 \\
  epsilon & float & stop iteration if changes fall below this value & 1.0  \\
  k & float & k the noise threshold ($\le 0$: adaptive) & -1 \\
  psi & string & Edge stopping funtion (ps1|ps2|tuckey|guess) & - \\
  \plugtabend
  
  \item [Remark:] For mor information see \cite{perona90:aniso}. 
  
  \end{description}

   
   \subsection{Bandpass intensity filter}
   \begin{description}
   \item [Plugin:]bandpass
   \item [Description:]An intensity band pass filter - all pixels with intensities
   outside the given range are set to zero, all other pixels remain the
   same ($x:=x\in [min,max]\:?\: x\::\:0$
   \item [Parameters:] min, max
   
   \plugtabstart
   min&  float&  lower bound of the bandpass range &0\\\hline
   max&  float&  upper bound of the bandpass range &3.40282e+38\\\hline
   \end{tabular}
   \end{description}
   

   \subsection{Binarize Filter}
   \begin{description}
   \item [Plugin:]binarize
   \item [Description:]An binarize filter - all pixels with intensities
   outside the given range are set to zero, all other pixels are set to one
   same ($x:=x\in [min,max]\:?\: x\::\:0$
   \item [Parameters:] min, max
   
   \plugtabstart
   min&  float&  lower bound of the intensity range &0\\\hline
   max&  float&  upper bound of the intensity range &3.40282e+38\\\hline
   \end{tabular}
   \end{description}
   
   
   \subsection{Downscale filter}
   \label{filter3d:downscale}
   
   \begin{description}
   
   \item [Plugin:] downscale
   \item [Description:] Downscale the input image by using a given block size to define the 
            downscale factor. Prior to scaling the image is filtered by a smoothing filter to eliminate 
	    high frequency data and avoid aliasing artifacts. 
   \item [Input:] Abitrary gray scale or binary image 
   \item [Output:] The downscaled image.  
   
   \plugtabstart
   bx & int & downscale factor in x direction & 1  \\
   by & int & downscale factor in y direction & 1  \\
   bz & int & downscale factor in z direction & 1  \\
   b & string & Alternative to define the scaling factors as a 3D vector & <1,1,1>  \\
   kernel & string & Base type of the smoothing kernel, the filter kernel width is estimated based 
       on the downscale factors & gauss \\\hline 
   \plugtabend
   
   \end{description}

   
   \subsection{Image cropping}
   \label{filter3d:crop}
   
   \begin{description}
   
   \item [Plugin:] crop
   \item [Description:] Crop a region of an image, the region is always clamped to the original image size. 
   \item [Input:] Abitray grayscale image 
   \item [Output:] A gray scale image that contains the cropped region. 
   
   \plugtabstart
   start & 3D vector & upper left corner of the requested sub-region  & <0,0,0>  \\
   end & 3D vector & lower right corner of the requested sub-region, a value of -1 refers the size of the 
      original image in that dimension  & <-1,-1, -1>  \\
   \plugtabend
   
   \end{description}

   
   \subsection{Intensity invert}
   \label{filter3d:invert}
   
   \begin{description}
   
   \item [Plugin:] invert
   \item [Description:] invert the image intensities. Inversion of an image $I$ is done by a linearly mapping using 
     $\forall x in I: x \rightarrow (\max(I) - x + \min(I))$ 
   
   \item [Input:] A gray scale image of abitrary pixel type. 
   \item [Output:] The inverted image 
   
   \end{description}
   
   This plug-in doesn't take parameters. 

   
   \subsection{Label connected components}
   \label{filter3d:label}
   
   \begin{description}
   
   \item [Plugin:] label
   \item [Description:] Label connected components 
   \item [Input:] Binary image 
   \item [Output:] An image of type unsigned char or unsigned short, depending on the number of components found. 
                  The first label is 1
   
   \plugtabstart
   shape &  string & neighbourhood shape as provided by the shape plug-ins \ref{sec:3dshapes} & 6n  \\
   \plugtabend
   
   \item [Remark:] A maximum of 65535 labels is supported. 

   \end{description}

   
   \subsection{Mean Least Variance filter}
   \label{filter3d:mlv}
   
   \begin{description}
   
   \item [Plugin:] mlv
   \item [Description:] Apply the mean least variance filter. 
   \item [Input:] Abitrary gray scale or binary image 
   \item [Output:] The filtered image of the same pixel type and dimension 
   
   \plugtabstart
   w & int & filter width parameter, the actual filter captures a neighborhood of 
                 $(4 * w + 1) \times (4 * w + 1) \times (4 * w + 1)$ voxels & 1 \\ 
   \plugtabend
   \end{description}

   
   \subsection{Median filter}
   \label{filter3d:median}
   
   \begin{description}
   
   \item [Plugin:] median
   \item [Description:] Apply the median filter. 
   \item [Input:] Abitrary gray scale or binary image 
   \item [Output:] The filtered image of the same pixel type and dimension 
   
   \plugtabstart
   w &  int & filter width parameter & 1  \\
   \plugtabend
   
   \end{description}

   
   \subsection{Morphological filters}
   \label{filter3d:morph}
   
   \begin{description}
   
   \item [Plugin:] dilate, erode, close, open
   \item [Description:] Apply the according morphological operation using a given structuring element 
   \item [Input:] Abitrary gray scale or binary image 
   \item [Output:] The filtered image of the same pixel type and dimension 
   
   \plugtabstart
   shape &  string & definition of the structuring element as provided by the shape plugins \ref{sec:3dshapes} & 
         sphere:r=2    \\
   hint  &  string & A hint to speed up the processing of binary images (black|white), should indicate 
         what kind of pixel is more presnt in the image  & black \\\hline 
   \plugtabend
   
   \end{description}

   
   \subsection{Pixel value conversion}
   \label{filter3d:convert}
   
   \begin{description}
   \item [Plugin:]convert
   \item [Description:] Pixel conversion filter
   \item [Conversions:] Mapping methods 
   \begin{description}
   \item [copy:] pixel values are copied, values outside of the target range are clipped
   \item [linear:] pixel values are transformed according to $x \rightarrow a \times x + b$ , 
       values outside of the target range are clipped
   \item [opt:] The range of the input pixels \emph{found in the input image} 
       is mapped to the range of the output type. 
   \item [range:] The range of the input pixel \emph{type} is mapped to the range of the output type. 
   \end{description}
   \item [Parameters:] a, b, map, repn
   
   \plugtabstart
   a&  float&  scaling for linear mapping & 1.0\\\hline
   b&  float&  shift of linear mapping    & 0.0\\\hline
   map& string & type of mapping (copy|linear|opt|range) & opt\\\hline
   repn & string & target pixel type ( sbyte | ubyte | sshort | ushort |
				sint | uint | slong | ulong | float | double) & ubyte \\\hline
   \plugtabend
   
   \end{description}

   
   \subsection{Region growing based on an initial seed mask}
   \label{filter3d:growmask}
   
   \begin{description}
   
   \item [Plugin:] growmask
   \item [Description:] Use an input binary mask and a reference gray scale image to do region growing 
                        by adding pixels as long as the have a lower intensity above a given threshold.  
   \item [Input:] Binary seed mask image.
   \item [Output:] Binary grown mask image. 
   
   \plugtabstart
   ref & string & reference image for mask region growing, may come from the data pool and must be of the same size 
	          like the seed mask image &  \\ 
   shape & string & neighborhood mask as provided by the shape plugins \ref{sec:3dshapes} & 6n \\
   min & float & lower threshold for mask growing & 1.0 \\
   \plugtabend
   
   \end{description}

   
   \subsection{Reorient image}
   \label{filter3d:reorient}
   
   \begin{description}
   
   \item [Plugin:] reorient
   \item [Description:] Change the orientation of the 3D image 
   \item [Input:] An abitary 3D image 
   \item [Input:] The re-oriented 3D image 

   \plugtabstart
   map & string & mapping to be applied & xyz \\
   \plugtabend
   \end{description}

   
   \subsection{Select biggest component}
   \label{filter3d:selectbig}
   
   \begin{description}
   
   \item [Plugin:] selectbig
   \item [Description:] A 3D filter that creats a binary mask representing the intensity with the highest pixel count. 
   The pixel value 0 will be ignored, and if two intensities have the same pixel count, then the result is undefined. 
   \item [Input:] An image with integral intensity values, usually this will be the output of the 
         label filter \ref{filter3d:label}. 
   \item [Input:] An binary image with a mask that represents the pixels with the highest pixel count. 

   This plug-in takes no parameters. 
   
   \end{description}

   
   \subsection{Spacial separable convolution filter}
   \label{filter3d:sepconv}
   
   \begin{description}
   
   \item [Plugin:] sepconv
   \item [Description:] A 3D image filter that runs separable ove each dimension 
   \item [Input:] Abitrary gray scale image 
   \item [Output:] Filtered gray scale image of the same pixel type and dimension
   
   \plugtabstart
   kx &  string & Filter kernel in x-direction as available through the spacial kernel plug-ins \ref{sec:SpacialKernels}
      & gauss:w=1    \\
   ky &  string & Filter kernel in y-direction as available through the spacial kernel plug-ins \ref{sec:SpacialKernels}
      & gauss:w=1    \\
   kz &  string & Filter kernel in z-direction as available through the spacial kernel plug-ins \ref{sec:SpacialKernels}
      & gauss:w=1    \\\hline 
   \plugtabend
   
   \end{description}

\section{3D image similarity kernels}  \label{sec:cost3d}
  
  3D image similarity kernels evaluate the according similarity measure between 
  two images. These kernels may be used standalone, like e.g. in linear registration, 
  or will be called from generalized image similarity cost plug-ins that also take 
  care of transforming and scaling the images during the image registration process. 

  In the following $\Omega$ is the image domain, and $S:\Omega\rightarrow \R$ stands  
  for the study or floating image, and  $R:\Omega\rightarrow \R$ for the reference or fixed image. 

   
   \subsection{Sum of Squared Differences}
   \label{cost3d:ssd}
   
   \begin{description}
   
   \item [Plugin:] ssd
   \item [Description:] Evaluates the Sum of Squared Differences similarity measure between two images:
   \begin{equation}
      F_\text{SSD} (S,R) = \frac{1}{2} \int_{\Omega} \left( S(x) - R(x) \right)^2 \text{d}x 
   \end{equation}
   \item [Study:] An abitrary gray scale or binary images 
   \item [Reference:] An abitrary gray scale or binary images 
   \end{description}
   
   This plug-in doesn't take additional parameters. 

\section{3D neighborhood shapes}  \label{sec:3dshapes}
  
  These 3D shapes define neighbourhoods for a variety of image processing filters, 
  like, e.g., morphological filters \ref{filter3d:morph}. 
  Shapes are always binary. 
  

  \subsection{Basic shapes}
  \label{shapes3d:basic}

  \begin{description}

   \item [Plugin:] 6n, 18n, 26n 
   \item [Description:] provide the simple neighbourhood shapes, 'o' indicates the center (that belongs to the shape) 
       and 'x' the additional elements. 

     \begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|}
     \hline 
      & \multicolumn{3}{|c|}{z=-1} &&  \multicolumn{3}{|c|}{z=0}  && \multicolumn{3}{|c|}{z=1}\\
     \hline 
     \multicolumn{12}{|c|}{}\\
     \hline 
     \multirow{3}{*}{6n}
     &   &   &   &&   & x &   &&  &   &   \\
     \cline{2-4}     \cline{6-8}      \cline{10-12}
     &   & x &   && x & o & x &&  & x &   \\
     \cline{2-4}     \cline{6-8}      \cline{10-12}
     &   &   &   &&   & x &   &&  &   &   \\
     \hline 
     \multicolumn{12}{|c|}{}\\
     \hline 
     \multirow{3}{*}{18n}
     &   & x &   && x & x & x &&   & x &    \\
     \cline{2-4}     \cline{6-8}      \cline{10-12}
     & x & x & x && x & o & x && x & x & x  \\
     \cline{2-4}     \cline{6-8}      \cline{10-12}
     &   & x &   && x & x & x &&   & x &    \\
     \hline 
     \multicolumn{12}{|c|}{}\\
     \hline 
     \multirow{3}{*}{26n}
     & x & x & x && x & x & x && x & x & x  \\
     \cline{2-4}     \cline{6-8}      \cline{10-12}
     & x & x & x && x & o & x && x & x & x  \\
     \cline{2-4}     \cline{6-8}      \cline{10-12}
     & x & x & x && x & x & x && x & x & x  \\
     \hline
     \end{tabular}
   
   \end{description}
   These plug-ins don't take parameters. 
   


  \subsection{Spherical shape}
  \label{shapes3d:sphere}

  \begin{description}
   
   \item [Plugin:] sphere 
   \item [Description:] provides a 3D filled sphere. 
   
   \end{description}
   \plugtabstart
   r &  float & radius of the sphere & 2 \\
   \plugtabend
   
\section{Minimizers}  \label{sec:minimizers}
  
  These minimizers are used to optimize functions of the type $F:\Omega \rightarrow \R$. 
  
  Minimizers are created by the CMinimizerPluginHandler singleton.

   
   \subsection{Minimizers provided by the GNU Scientific Library}
   \label{minimizer:gsl}
   
   \begin{description}
   
   \item [Plugin:] gsl
   \item [Description:] This plugin provides minimizers that are implemented in the GNU Scientific Library
                        \cite{galassi09}
			Currently, the following optimizers are supported: 
			
			\begin{tabular}{|c|l|c|}
			\hline 
			Name & Description & uses Gradient \\\hline 
			simplex & The simplex algorithm \cite{nelder65}, currently the 
			          stopping criterion is set to  $10^{-3}$ & no \\
			bfgs    &  Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm & yes \\
			bfgs2  &   Alternative Implementation of the BFGS algorithm & yes \\
			cg-fr &  Fletcher-Reeves conjugate gradient algorithm & yes \\
			cg-fr &  Polak-Ribiere conjugate gradient algorithm  & yes \\
			gd & Gradient Descent & yes \\
			\hline 
			\end{tabular}

   \plugtabstart
   opt  & string & Optimization methos (see above) & gd \\
   tol  & double & Stopping criterion $\in[0.001,10]$;  actual meaning depends on the algorithm & 0.1 \\
   eps  & double & gradient norm stopping criterion (stop when |g| < eps) $\in [10^{-10}, 10.0]$ & 0.01 \\
   iter & int & maximum number of iterations & 100 \\
   step & double & initial step size $\in [0, 10]$ & 0.001 \\
   \plugtabend
   
   \end{description}

   
   \subsection{Minimizers provided by the NLOpt Library}
   \label{minimizer:nlopt}
   
   \begin{description}
   
   \item [Plugin:] nlopt
   \item [Description:] This plugin provides minimizers that are implemented in the NLopt Library
                        \cite{johnson11}. 
			A wide range of optimizers is supported - for details please see the original source.  
			The naming scheme for the algoritm identifier is xy-name with 
			\begin {itemize}
			\item x g=global, l=local
			\item y n=no derivative used, d=derivative used
			\item name the name of the algorithm including further specifications. 
			\end {itemize}
   \plugtabstart
   opt & string & main minimization algorithm &  not given\\
   local-opt & string & secondary minimization algorithm (some of the main algorithms need this, 
                       all parameters that are used for the main algorithm are currently also 
		       used for the local one &  not given\\
   stop & double & Stopping criterion: function value falls below this value & -HUGE \\
   xtola & double & Stopping criterion: the absolute change of all x-values is below this value & 0.0 \\
   xtolr & double & Stopping criterion: the relative change of all x-values is below this value & 0.0 \\
   ftola & double & Stopping criterion: the relative change of the objective value is below  this value & 0.0 \\
   ftolr & double & Stopping criterion: the relative change of all objective value  is below this value & 0.0 \\
   maxiter & int & Stopping criterion: the maximum number of iterations & 100 \\
   step & double & Initial step size & 0.0 \\
   \plugtabend
   
   \item [Remark:] The default values for all but the maxiter the stopping criterions correspond to 
                   "not used". Usually it is only required to set some of the stopping criterions. 
   \end{description}

\section{Noise Generators}  \label{sec:noisegen}
  
  These plug-ins are used to create specific types of random data. 
  
  Noise Generators are created by the CNoiseGeneratorPluginHandler singleton.

   
   \subsection{Gaussian noise generator}
   \label{noise:gauss}
   
   \begin{description}
   
   \item [Plugin:] gauss
   \item [Description:] This noise generator creates random values that are distributed according to a 
        Gaussien distribution by using the Box-Muller transformation. 

   \plugtabstart
   mu & float & mean of the Gaussian distribution & 0 \\
   sigma & float & standart derivation of the Gaussian  distribution & 1 \\
   seed & unsigned & Seed value for the initialization of the pseudo-number generator, 0 indicates to 
   use the current system time value returned by the time(NULL) function. & 0 \\
   \plugtabend

   \end{description}

   
   \subsection{Uniform noise generator}
   \label{noise:uniform}
   
   \begin{description}
   
   \item [Plugin:] uniform
   \item [Description:] This noise generator creates (pseudo) random values that are uniformly distributed over 
        a range [a,b]. 

   \plugtabstart
   a & float & Begin of noise value output range & 0 \\
   b & float & End of noise value output range & 1 \\
   seed & unsigned & Seed value for the initialization of the pseudo-number generator, 0 indicates to 
   use the current system time value returned by the time(NULL) function. & 0 \\
   \plugtabend
      

   \end{description}

\section{Spacial filter kernels}  \label{sec:SpacialKernels}
  
  These plug-ins provide kernels for 1D separable filtering. 
  
   
   \subsection{Gauss}
   \label{skernel:gauss}
   
   \begin{description}
   
   \item [Plugin:] gauss
   \item [Description:] The spacial Gauss kernel 
   
   \plugtabstart
   w &  int & half kernel with, the full kernel with is 2*w+1 & 1  \\
   \plugtabend
   
   \end{description}

